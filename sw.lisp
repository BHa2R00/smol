#!/usr/bin/sbcl --script 
(defmacro argv () `sb-ext:*posix-argv*)
(defun <- (l a b)
  (cond
    ((equalp l a) b)
    ((atom l) l)
    (t (map 'list (lambda (li) (<- li a b)) l))))
(defparameter *src*
  '((#\M #b1)))
(defparameter *alu*
  '(
    (C0      #b10100100) (C1      #b11110101) (C-1     #b11100100) 
    (D       #b00110000) (A       #b11000000) 
    (!D      #b00110001) (!A      #b11000001) 
    (-D      #b00110101) (-A      #b11000101) 
    (D+1     #b01110101) (A+1     #b11010101) 
    (D-1     #b00110100) (A-1     #b11000100) 
    (D+A     #b00000100) 
    (D-A     #b01000101) (A-D     #b00010101) 
    (D&A     #b00000000) 
    (DVA     #b01010001) 
    (D<<A    #b00001100) (A<<D    #b00001000) 
    (!D<<A   #b01001100) (A<<!D   #b01001000) 
    (D<<A    #b00001100) (D<<A    #b00001000) 
    (!A<<D   #b00011100) (D<<!A   #b00011000) 
    (D!<<A   #b00001101) (A!<<D   #b00001001) 
    (!D!<<A  #b01001101) (A!<<!D  #b01001001) 
    (D!<<A   #b00001101) (D!<<A   #b00001001) 
    (!A!<<D  #b00011101) (D!<<!A  #b00011001) 
    (^C1     #b11110111) 
    (^D      #b00110010) (^A      #b11000010) 
    (!^D     #b00110011) (!^A     #b11000011) 
    (-^D     #b00110111) (-^A     #b11000111) 
    (^D+1    #b01110111) (^A+1    #b11010111) 
    (^D-1    #b00110110) (^A-1    #b11000110) 
    (D^+A    #b00000110) 
    (D^-A    #b01000111) (A^-D    #b00010111) 
    (D^&A    #b00000010) 
    (D^VA    #b01010011) 
    (D^<<A   #b00001110) (A^<<D   #b00001010) 
    (!D^<<A  #b01001110) (A^<<!D  #b01001010) 
    (D^<<A   #b00001110) (D^<<A   #b00001010) 
    (!A^<<D  #b00011110) (D^<<!A  #b00011010) 
    (D!^<<A  #b00001111) (A!^<<D  #b00001011) 
    (!D!^<<A #b01001111) (A!^<<!D #b01001011) 
    (D!^<<A  #b00001111) (D!^<<A  #b00001011) 
    (!A!^<<D #b00011111) (D!^<<!A #b00011011) 
    ))
(defparameter *dst*
  '(
    (NIL #b000)
    (M   #b001) (D   #b010) (MD  #b011)
    (A   #b100) (AM  #b101) (AD  #b110) (AMD #b111)
    ))
(defparameter *jmp*
  '(
    (NIL #b000) 
    (JEQ #b010) (JNE #b101) 
    (JGT #b001) (JGE #b011)
    (JLT #b100) (JLE #b110)
    (JMP #b111)
    ))
(defparameter *cinst* (list))
(defun cinstname (d a j)
  (read-from-string
    (with-output-to-string (s)
      (if d (format s "~A=" d))
      (format s "~A" a)
      (if j (format s "?~A" j))
      )))
(map 'list
     (lambda (jmp)
       (map 'list
            (lambda (dst)
              (map 'list
                   (lambda (alu)
                     (let ((a (with-output-to-string (s) (format s "~A" (car alu))))
                           (c 1))
                       (setf c (logior c (ash (cadr jmp) 1)))
                       (setf c (logior c (ash (cadr dst) 4)))
                       (setf c (logior c (ash (cadr alu) 8)))
                       (push (list (cinstname (car dst) a (car jmp)) c) *cinst*)
                       (if (position #\A a)
                         (map 'list
                              (lambda (src)
                                (let ((a1 (substitute (car src) #\A a)))
                                  (setf c (logior c (ash (cadr src) 7)))
                                  (push (list (cinstname (car dst) a1 (car jmp)) c) *cinst*)
                                  ))
                              *src*))
                       ))
                   *alu*))
            *dst*))
     *jmp*)
(setf *cinst* (reverse *cinst*))
(defparameter *mode* nil)
(defparameter *mem* (list))
(defparameter *ram* #x1000)
(defparameter *label* (list))
(defparameter *value* (list))
(defparameter *lambda* (list))
(defparameter *debug* nil)
(defun asm (s)
  (do ((a (read s nil 'end)
          (read s nil 'end)))
    ((equalp a 'end))
    (cond
      ((assoc a *value*) 
       (let ()
         (push (caddr (assoc a *value*)) *mem*)
         (if *debug* (format t "~4,'0x : ~15A ~4,'0x~%" (* 2 (1-(length *mem*))) a (car *mem*)))
         ))
      ((assoc a *label*) 
       (let ()
         (push (cadr(assoc a *label*)) *mem*)
         (if *debug* (format t "~4,'0x : ~15A ~4,'0x~%" (* 2 (1-(length *mem*))) a (car *mem*)))
         ))
      ((assoc a *cinst*) 
       (let ()
         (push (cadr(assoc a *cinst*)) *mem*)
         (if *debug* (format t "~4,'0x : ~15A ~4,'0x~%" (* 2 (1-(length *mem*))) a (car *mem*)))
         ))
      ((listp a)
       (cond
         ((and
            (car a)
            (member (car a) '(inc include))
            (cadr a)
            (stringp (cadr a))
            (probe-file (cadr a))
            )
          (let ()
            (if *debug* (format t "include ~A~%" (cadr a)))
            (with-open-file (s1 (cadr a) :direction :input) (asm s1))
            ))
         ((and
            (assoc (car a) *lambda*)
            (= (length (cdr a)) (length (cadr (assoc (car a) *lambda*))))
            )
          (let ((i (cdr a))
                (v (cadr (assoc (car a) *lambda*)))
                (b (cddr (assoc (car a) *lambda*)))
                (b1 (list))
                (buf ""))
            (setf b1 b)
            (map 'list (lambda (vi ii) (setf b1 (<- b1 vi ii))) v i)
            (if *debug* (format t "~A -> ~A~%" a b1))
            (setf buf (with-output-to-string (s1) (format s1 "~{~S ~}" b1)))
            (with-input-from-string (s1 buf) (asm s1))
            ))
         ((and (listp (car a)) (cdr a))
          (let ((b (cdr a))
                (buf ""))
            (setf buf (with-output-to-string (s1) (format s1 "~{~S ~}" b)))
            (with-input-from-string (s1 buf) (asm s1))
            ))
         ((and (listp (cadr a)) (cddr a))
          (let ()
            (push a *lambda*)
            (if *debug* (format t "~S~%" (car *lambda*)))
            ))
         ((and (cadr a) (numberp (cadr a)))
          (let ()
            (push (append a (list (ash *ram* 1))) *value*)
            (if *debug* (format t "~4,'0x : ~A~%" (car(reverse(car *value*))) a))
            (incf *ram* (cadr a))
            ))
         (t
          (let ()
            (push (list (car a) (ash (length *mem*) 2)) *label*)
            (if *debug* (format t "~4,'0x : ~15A~%" (* 2 (length *mem*)) a))
            ))
         ))
      ((numberp a) 
       (let ()
         (if (< a 0)
           (push (ash (1+(lognot(abs a))) 1) *mem*)
           (push (ash a 1) *mem*)
           )
         (if *debug* (format t "~4,'0x : ~15A ~4,'0x~%" (* 2 (1-(length *mem*))) a (car *mem*)))
         ))
      ((atom a) 
       (let ()
         (push a *mem*)
         (if *debug* (format t "~4,'0x : ~15A ~%" (* 2 (1-(length *mem*))) (car *mem*)))
         ))
      (t (format t "syntax error : ~A~%" a)))
    ))

(let ((argvs (argv)))
  (dotimes (k (length argvs))
    (cond
      ((or
         (<= (length (argv)) 1)
         (equalp (nth k argvs) "-h"))
       (let ()
         (format t "-h help~%")
         (format t "-g debug on~%")
         (format t "-ram <addr>~%")
         (format t "asm ~%")
         (format t "    -print-all-insts ~%")
         (format t "    -i <input asm file>~%")
         (format t "    -o <output memh>~%")
         (format t "bin ~%")
         (format t "    -o <output binary>~%")
         ))
      ((equalp (nth k argvs) "-g") (setf *debug* t))
      ((equalp (nth k argvs) "-ram") (setf *ram* (read-from-string(nth (1+ k) argvs))))
      ((equalp (nth k argvs) "asm") (setf *mode* 'asm))
      ((equalp (nth k argvs) "bin") (setf *mode* 'bin))
      ((and
         (equalp *mode* 'asm)
         (equalp (nth k argvs) "-print-all-insts"))
       (let ((k 0))
         (format t "| ASM             : HEX ~%")
         (dotimes (j 8) (format t "-------------------------")) (format t "~%")
         (map 'list
              (lambda (i)
                (format t "| ~15A : ~4,'0X " (nth 0 i) (cadr i))
                (if (= 7 (rem k 8)) (format t "~%"))
                (incf k)
                )
              *cinst*)
         ))
      ((equalp (nth k argvs) "-i")
       (case *mode*
         ('asm 
          (let ()
            (with-open-file (s (nth (1+ k) argvs) :direction :input) (asm s))
            ))
         ))
      ((equalp (nth k argvs) "-o")
       (case *mode*
         ('asm 
          (let ((err nil))
            (setf *mem* 
                  (map 'list 
                       (lambda (m) 
                         (if (numberp m)
                           m
                           (if (assoc m *label*) 
                             (let ((c (cadr(assoc m *label*))))
                               (if *debug* (format t "~4,'0X = ~A~%" c m))
                               c)
                             (let ()
                               (setf err t)
                               (if *debug* (format t "no define: ~A~%" m))
                               m)))
                         ) 
                       *mem*))
            (if (not err)
            (let ((m (list)))
              (do ((u (pop *mem*) (pop *mem*))) 
                ((not *mem*)
                 (let ()
                   (push (logand #xff (ash u -8)) m)
                   (push (logand #xff u) m)
                   (setf *mem* m)))
                (push (logand #xff (ash u -8)) m)
                (push (logand #xff u) m))))
            (with-open-file (s (nth (1+ k) argvs) 
                                  :direction :output
                                  :if-does-not-exist :create
                                  :if-exists :supersede
                                  ) 
                 (format s "~{~2,'0x~%~}" *mem*))))
         ('bin
          (let ()
            (with-open-file (s (nth (1+ k) argvs) 
                                  :direction :output
                                  :if-does-not-exist :create
                                  :if-exists :supersede
                                  :element-type '(unsigned-byte 8)
                                  ) 
                 (map 'list
                      (lambda (b)
                        (write-byte b s))
                      *mem*))
            ))
         ))
      ))
  )
