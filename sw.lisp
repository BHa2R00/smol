#!/usr/bin/sbcl --script 
(defmacro argv () `sb-ext:*posix-argv*)
(defun <- (l a b)
  (cond
    ((equalp l a) b)
    ((atom l) l)
    (t (map 'list (lambda (li) (<- li a b)) l))))
(defparameter *src*
  '((#\M #b1)))
(defparameter *alu*
  '(
    (C0      #b00101001) (C1      #b01111101) (C-1     #b00111001) 
    (D       #b00001100) (A       #b00110000) 
    (!D      #b01001100) (!A      #b01110000) 
    (-D      #b01001101) (-A      #b01110001) 
    (D+1     #b01011101) (A+1     #b01110101) 
    (D-1     #b00001101) (A-1     #b00110001) 
    (D+A     #b00000001)              
    (D-A     #b01010001) (A-D     #b01000101) 
    (D&A     #b00000000)              
    (DVA     #b01010100)              
    (D<<A    #b00000011) (A<<D    #b00000010) 
    (!D<<A   #b00010011) (A<<!D   #b00010010) 
    (D<<A    #b00000011) (D<<A    #b00000010) 
    (!A<<D   #b00000111) (D<<!A   #b00000110) 
    (D!<<A   #b01000011) (A!<<D   #b01000010) 
    (!D!<<A  #b01010011) (A!<<!D  #b01010010) 
    (D!<<A   #b01000011) (D!<<A   #b01000010) 
    (!A!<<D  #b01000111) (D!<<!A  #b01000110) 
    (^C1     #b11111101)              
    (^D      #b10001100) (^A      #b10110000) 
    (!^D     #b11001100) (!^A     #b11110000) 
    (-^D     #b11001101) (-^A     #b11110001) 
    (^D+1    #b11011101) (^A+1    #b11110101) 
    (^D-1    #b10001101) (^A-1    #b10110001) 
    (D^+A    #b10000001)              
    (D^-A    #b11010001) (A^-D    #b11000101) 
    (D^&A    #b10000000)              
    (D^VA    #b11010100)              
    (D^<<A   #b10000011) (A^<<D   #b10000010) 
    (!D^<<A  #b10010011) (A^<<!D  #b10010010) 
    (D^<<A   #b10000011) (D^<<A   #b10000010) 
    (!A^<<D  #b10000111) (D^<<!A  #b10000110) 
    (D!^<<A  #b11000011) (A!^<<D  #b11000010) 
    (!D!^<<A #b11010011) (A!^<<!D #b11010010) 
    (D!^<<A  #b11000011) (D!^<<A  #b11000010) 
    (!A!^<<D #b11000111) (D!^<<!A #b11000110) 
    ))
(defparameter *dst*
  '(
    (NIL #b000)
    (M   #b001) (D   #b010) (MD  #b011)
    (A   #b100) (AM  #b101) (AD  #b110) (AMD #b111)
    ))
(defparameter *jmp*
  '(
    (NIL #b000) 
    (JEQ #b010) (JNE #b101) 
    (JGT #b001) (JGE #b011)
    (JLT #b100) (JLE #b110)
    (JMP #b111)
    ))
(defparameter *cinst* (list))
(defun cinstname (d a j)
  (read-from-string
    (with-output-to-string (s)
      (if d (format s "~A=" d))
      (format s "~A" a)
      (if j (format s "?~A" j))
      )))
(map 'list
     (lambda (jmp)
       (map 'list
            (lambda (dst)
              (map 'list
                   (lambda (alu)
                     (let ((a (with-output-to-string (s) (format s "~A" (car alu))))
                           (c 1))
                       (setf c (logior c (ash (cadr jmp) 13)))
                       (setf c (logior c (ash (cadr dst) 10)))
                       (setf c (logior c (ash (cadr alu) 2)))
                       (push (list (cinstname (car dst) a (car jmp)) c) *cinst*)
                       (if (position #\A a)
                         (map 'list
                              (lambda (src)
                                (let ((a1 (substitute (car src) #\A a)))
                                  (setf c (logior c (ash (cadr src) 1)))
                                  (push (list (cinstname (car dst) a1 (car jmp)) c) *cinst*)
                                  ))
                              *src*))
                       ))
                   *alu*))
            *dst*))
     *jmp*)
(setf *cinst* (reverse *cinst*))
(defparameter *mode* nil)
(defparameter *data* #x1000)
(defparameter *size* #x1100)
(defparameter *mem* (list))
(defparameter *label* (list))
(defparameter *value* (list))
(defparameter *lambda* (list))
(defparameter *debug* nil)
(defun asm (s)
  (do ((a (read s nil 'end)
          (read s nil 'end)))
    ((equalp a 'end))
    (cond
      ((assoc a *value*) 
       (let ()
         (push (caddr (assoc a *value*)) *mem*)
         (if *debug* (format t "~4,'0x : ~15A ~4,'0x~%" (* 2 (1-(length *mem*))) a (car *mem*)))
         ))
      ((assoc a *label*) 
       (let ()
         (push (cadr(assoc a *label*)) *mem*)
         (if *debug* (format t "~4,'0x : ~15A ~4,'0x~%" (* 2 (1-(length *mem*))) a (car *mem*)))
         ))
      ((assoc a *cinst*) 
       (let ()
         (push (cadr(assoc a *cinst*)) *mem*)
         (if *debug* (format t "~4,'0x : ~15A ~4,'0x~%" (* 2 (1-(length *mem*))) a (car *mem*)))
         ))
      ((listp a)
       (cond
         ((and
            (car a)
            (member (car a) '(inc include))
            (cadr a)
            (stringp (cadr a))
            (probe-file (cadr a))
            ) ;; include file : (inc path)
          (let ()
            (if *debug* (format t "include ~A~%" (cadr a)))
            (with-open-file (s1 (cadr a) :direction :input) (asm s1))
            ))
         ((and
            (assoc (car a) *lambda*)
            (= (length (cdr a)) (length (cadr (assoc (car a) *lambda*))))
            ) ;; expand macro : (macroname argvs... )
          (let ((i (cdr a))
                (v (cadr (assoc (car a) *lambda*)))
                (b (cddr (assoc (car a) *lambda*)))
                (b1 (list))
                (buf ""))
            (setf b1 b)
            (map 'list (lambda (vi ii) (setf b1 (<- b1 vi ii))) v i)
            (if *debug* (format t "~A -> ~A~%" a b1))
            (setf buf (with-output-to-string (s1) (format s1 "~{~S ~}" b1)))
            (with-input-from-string (s1 buf) (asm s1))
            ))
         ((and 
            (listp (car a)) (cdr a) 
            (atom (car(car a)))
            (or
              (stringp (cadr(car a)))
              (listp (cadr(car a)))
              (vectorp (cadr(car a))))) ;; map : ((char/value "string"/#(vector)) body... )
          (let ((l (coerce (cadr(car a)) 'list))
                (i (car(car a)))
                (b (cdr a))
                (buf ""))
            (map 'list
                 (lambda (li)
                   (setf buf 
                         (with-output-to-string (s1) 
                           (format s1 "~S" (append (list(list(list i li))) b))))
                   (with-input-from-string (s1 buf) (asm s1))
                   )
                 l)
            ))
         ((and (listp (car a)) (cdr a)) ;; lambda : ((binds... ) body... )
          (let ((i (car a))
                (b (cdr a))
                (buf ""))
            (map 'list (lambda (ik) (setf b (<- b (car ik) (cadr ik)))) i)
            (setf buf (with-output-to-string (s1) (format s1 "~{~S ~}" b)))
            (with-input-from-string (s1 buf) (asm s1))
            ))
         ((and (listp (cadr a)) (cddr a)) ;; define macro : (macroname (args... ) body... )
          (let ()
            (push a *lambda*)
            (if *debug* (format t "~S~%" (car *lambda*)))
            ))
         ((and (cadr a) (numberp (cadr a))) ;; define value : (name bytes)
          (let ()
            (push (append a (list (logand #xffff (ash *data* 1)))) *value*)
            (if *debug* (format t "~4,'0x : ~A~%" (car(reverse(car *value*))) a))
            (incf *data* (cadr a))
            ))
         (t ;; label: (name) 
          (let ()
            (push (list (car a) (logand #xffff (ash (length *mem*) 2))) *label*)
            (if *debug* (format t "~4,'0x : ~15A~%" (* 2 (length *mem*)) a))
            ))
         ))
      ((numberp a) ;; constant number : number 
       (let ()
         (if (< a 0)
           (push (logand #xffff (ash (1+(lognot(abs a))) 1)) *mem*)
           (push (logand #xffff (ash a 1)) *mem*)
           )
         (if *debug* (format t "~4,'0x : ~15A ~4,'0x~%" (* 2 (1-(length *mem*))) a (car *mem*)))
         ))
      ((characterp a) ;; constant number : char #\ 
       (let ()
         (push (logand #xffff (ash (char-code a) 1)) *mem*)
         (if *debug* (format t "~4,'0x : ~15A ~4,'0x~%" (* 2 (1-(length *mem*))) a (car *mem*)))
         ))
      ((atom a) ;; unallocated label refer 
       (let ()
         (push a *mem*)
         (if *debug* (format t "~4,'0x : ~15A ~%" (* 2 (1-(length *mem*))) (car *mem*)))
         ))
      (t (format t "syntax error : ~A~%" a)))
    ))

(let ((argvs (argv)))
  (dotimes (k (length argvs))
    (cond
      ((or
         (<= (length (argv)) 1)
         (equalp (nth k argvs) "-h"))
       (let ()
         (format t "-h help~%")
         (format t "-g debug on~%")
         (format t "-data [data section base addr]~%")
         (format t "asm ~%")
         (format t "    -print-all-insts ~%")
         (format t "    -i [input asm file]~%")
         (format t "    -o [output memh]~%")
         (format t "bin ~%")
         (format t "    -o [output binary]~%")
         ))
      ((equalp (nth k argvs) "-g") (setf *debug* t))
      ((equalp (nth k argvs) "-data") (setf *data* (read-from-string(nth (1+ k) argvs))))
      ((equalp (nth k argvs) "asm") (setf *mode* 'asm))
      ((equalp (nth k argvs) "bin") (setf *mode* 'bin))
      ((and
         (equalp *mode* 'asm)
         (equalp (nth k argvs) "-print-all-insts"))
       (let ((k 0))
         (format t "| ASM             : HEX ~%")
         (dotimes (j 8) (format t "-------------------------")) (format t "~%")
         (map 'list
              (lambda (i)
                (format t "| ~15A : ~4,'0X " (nth 0 i) (cadr i))
                (if (= 7 (rem k 8)) (format t "~%"))
                (incf k)
                )
              *cinst*)
         ))
      ((equalp (nth k argvs) "-i")
       (case *mode*
         ('asm 
          (let ()
            (with-open-file (s (nth (1+ k) argvs) :direction :input) (asm s))
            ))
         ))
      ((equalp (nth k argvs) "-o")
       (case *mode*
         ('asm 
          (let ((err nil))
            (setf *mem* 
                  (map 'list 
                       (lambda (m) 
                         (if (numberp m)
                           m
                           (if (assoc m *label*) 
                             (let ((c (cadr(assoc m *label*))))
                               (if *debug* (format t "~4,'0X = ~A~%" c m))
                               c)
                             (let ()
                               (setf err t)
                               (if *debug* (format t "no define: ~A~%" m))
                               m)))
                         ) 
                       *mem*))
            (if (not err)
            (let ((m (list)))
              (do ((u (pop *mem*) (pop *mem*))) 
                ((not *mem*)
                 (let ()
                   (push (logand #xff (ash u -8)) m)
                   (push (logand #xff u) m)
                   (setf *mem* m)))
                (push (logand #xff (ash u -8)) m)
                (push (logand #xff u) m))))
            (with-open-file (s (nth (1+ k) argvs) 
                                  :direction :output
                                  :if-does-not-exist :create
                                  :if-exists :supersede
                                  ) 
                 (format s "~{~2,'0x~%~}" *mem*))))
         ('bin
          (let ()
            (with-open-file (s (nth (1+ k) argvs) 
                                  :direction :output
                                  :if-does-not-exist :create
                                  :if-exists :supersede
                                  :element-type '(unsigned-byte 8)
                                  ) 
                 (map 'list
                      (lambda (b)
                        (write-byte b s))
                      *mem*))
            ))
         ))
      ))
  )
